{"ast":null,"code":"/**\r\n * @module  to-array-buffer\r\n */\n'use strict';\n\nvar str2ab = require('string-to-arraybuffer');\n\nvar flat = require('flatten-vertex-data'); // var isBlob = require('is-blob')\n\n\nmodule.exports = function toArrayBuffer(arg) {\n  //zero-length or undefined-like\n  if (!arg) return new ArrayBuffer(); //array buffer\n\n  if (arg instanceof ArrayBuffer) return arg; //try to decode data-uri\n\n  if (typeof arg === 'string') {\n    return str2ab(arg);\n  } // File & Blob\n  // if (isBlob(src) || (src instanceof global.File)) {\n  // FIXME: we cannot use it here bc FileReader is async\n  // }\n  //array buffer view: TypedArray, DataView, Buffer etc\n\n\n  if (ArrayBuffer.isView(arg)) {\n    if (arg.byteOffset != null) return arg.buffer.slice(arg.byteOffset, arg.byteOffset + arg.byteLength);\n    return arg.buffer;\n  } //buffer/data nested: NDArray, ImageData etc.\n  //FIXME: NDArrays with custom data type may be invalid for this procedure\n\n\n  if (arg.buffer || arg.data || arg._data) {\n    var result = toArrayBuffer(arg.buffer || arg.data || arg._data);\n    return result;\n  } // detect if flat\n\n\n  if (arg.length != null) {\n    for (var i = 0; i < arg.length; i++) {\n      if (arg[i].length != null) {\n        arg = flat(arg);\n        break;\n      }\n    }\n  } //array-like or unknown\n  //hope Uint8Array knows better how to treat the input\n\n\n  return new Uint8Array(arg.length != null ? arg : [arg]).buffer;\n};","map":{"version":3,"sources":["/Users/kaspar/Documents/GitHub/React-Django-startApp/node_modules/to-array-buffer/index.js"],"names":["str2ab","require","flat","module","exports","toArrayBuffer","arg","ArrayBuffer","isView","byteOffset","buffer","slice","byteLength","data","_data","result","length","i","Uint8Array"],"mappings":"AAAA;AACA;AACA;AAEA;;AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,uBAAD,CAApB;;AACA,IAAIC,IAAI,GAAGD,OAAO,CAAC,qBAAD,CAAlB,C,CACA;;;AAGAE,MAAM,CAACC,OAAP,GAAiB,SAASC,aAAT,CAAwBC,GAAxB,EAA6B;AAC7C;AACA,MAAI,CAACA,GAAL,EAAU,OAAO,IAAIC,WAAJ,EAAP,CAFmC,CAI7C;;AACA,MAAID,GAAG,YAAYC,WAAnB,EAAgC,OAAOD,GAAP,CALa,CAO7C;;AACA,MAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AAC5B,WAAON,MAAM,CAACM,GAAD,CAAb;AACA,GAV4C,CAY7C;AACA;AACC;AACD;AAEA;;;AACA,MAAIC,WAAW,CAACC,MAAZ,CAAmBF,GAAnB,CAAJ,EAA6B;AAC5B,QAAIA,GAAG,CAACG,UAAJ,IAAkB,IAAtB,EAA4B,OAAOH,GAAG,CAACI,MAAJ,CAAWC,KAAX,CAAiBL,GAAG,CAACG,UAArB,EAAiCH,GAAG,CAACG,UAAJ,GAAiBH,GAAG,CAACM,UAAtD,CAAP;AAC5B,WAAON,GAAG,CAACI,MAAX;AACA,GArB4C,CAuB7C;AACA;;;AACA,MAAIJ,GAAG,CAACI,MAAJ,IAAcJ,GAAG,CAACO,IAAlB,IAA0BP,GAAG,CAACQ,KAAlC,EAAyC;AACxC,QAAIC,MAAM,GAAGV,aAAa,CAACC,GAAG,CAACI,MAAJ,IAAcJ,GAAG,CAACO,IAAlB,IAA0BP,GAAG,CAACQ,KAA/B,CAA1B;AACA,WAAOC,MAAP;AACA,GA5B4C,CA8B7C;;;AACA,MAAIT,GAAG,CAACU,MAAJ,IAAc,IAAlB,EAAwB;AACvB,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGX,GAAG,CAACU,MAAxB,EAAgCC,CAAC,EAAjC,EAAqC;AACpC,UAAIX,GAAG,CAACW,CAAD,CAAH,CAAOD,MAAP,IAAiB,IAArB,EAA2B;AAC1BV,QAAAA,GAAG,GAAGJ,IAAI,CAACI,GAAD,CAAV;AACA;AACA;AACD;AACD,GAtC4C,CAwC7C;AACA;;;AACA,SAAQ,IAAIY,UAAJ,CAAeZ,GAAG,CAACU,MAAJ,IAAc,IAAd,GAAqBV,GAArB,GAA2B,CAACA,GAAD,CAA1C,CAAD,CAAmDI,MAA1D;AACA,CA3CD","sourcesContent":["/**\r\n * @module  to-array-buffer\r\n */\r\n\r\n'use strict'\r\n\r\nvar str2ab = require('string-to-arraybuffer')\r\nvar flat = require('flatten-vertex-data')\r\n// var isBlob = require('is-blob')\r\n\r\n\r\nmodule.exports = function toArrayBuffer (arg) {\r\n\t//zero-length or undefined-like\r\n\tif (!arg) return new ArrayBuffer()\r\n\r\n\t//array buffer\r\n\tif (arg instanceof ArrayBuffer) return arg\r\n\r\n\t//try to decode data-uri\r\n\tif (typeof arg === 'string') {\r\n\t\treturn str2ab(arg)\r\n\t}\r\n\r\n\t// File & Blob\r\n\t// if (isBlob(src) || (src instanceof global.File)) {\r\n\t\t// FIXME: we cannot use it here bc FileReader is async\r\n\t// }\r\n\r\n\t//array buffer view: TypedArray, DataView, Buffer etc\r\n\tif (ArrayBuffer.isView(arg)) {\r\n\t\tif (arg.byteOffset != null) return arg.buffer.slice(arg.byteOffset, arg.byteOffset + arg.byteLength)\r\n\t\treturn arg.buffer\r\n\t}\r\n\r\n\t//buffer/data nested: NDArray, ImageData etc.\r\n\t//FIXME: NDArrays with custom data type may be invalid for this procedure\r\n\tif (arg.buffer || arg.data || arg._data) {\r\n\t\tvar result = toArrayBuffer(arg.buffer || arg.data || arg._data)\r\n\t\treturn result\r\n\t}\r\n\r\n\t// detect if flat\r\n\tif (arg.length != null) {\r\n\t\tfor (var i = 0; i < arg.length; i++) {\r\n\t\t\tif (arg[i].length != null) {\r\n\t\t\t\targ = flat(arg)\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t//array-like or unknown\r\n\t//hope Uint8Array knows better how to treat the input\r\n\treturn (new Uint8Array(arg.length != null ? arg : [arg])).buffer\r\n}\r\n"]},"metadata":{},"sourceType":"script"}