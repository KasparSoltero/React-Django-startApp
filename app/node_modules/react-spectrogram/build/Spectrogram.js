var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import React from "react";
var Spectrogram = function (_a) {
    var data = _a.data, layout = _a.layout, options = _a.options;
    var lineCanvasRef = React.useRef(null);
    var heatmapCanvasRef = React.useRef(null);
    var minYScaleValue = options.yAxis.values[0];
    var maxYScaleValue = options.yAxis.values[options.yAxis.values.length - 1];
    var containerStyle = {
        paddingTop: layout === null || layout === void 0 ? void 0 : layout.paddingTop,
        paddingRight: layout === null || layout === void 0 ? void 0 : layout.paddingRight,
        paddingBottom: layout === null || layout === void 0 ? void 0 : layout.paddingBottom,
        paddingLeft: layout === null || layout === void 0 ? void 0 : layout.paddingLeft
    };
    var lineContainerStyle = {
        position: "relative"
    };
    var heatmapContainerStyle = {
        position: "relative",
        marginTop: layout.heatmap.marginTop
    };
    var heatmapCanvasStyle = {};
    var canvasStyle = {
        display: "block"
    };
    var scaleContainerStyle = {};
    // util function
    var fillStyle = React.useMemo(function () {
        switch (options === null || options === void 0 ? void 0 : options.theme) {
            case "black-white":
                return function (x) {
                    return "rgb(" + x + "," + x + "," + x + ")";
                };
            case "white-black":
                return function (x) {
                    x = 255 - x;
                    return "rgb(" + x + "," + x + "," + x + ")";
                };
            case "black-red":
                return function (x) {
                    return "rgb(" + x + ",0,0)";
                };
            case "black-green":
                return function (x) {
                    return "rgb(0," + x + ",0)";
                };
            case "black-blue":
                return function (x) {
                    return "rgb(0,0," + x + ")";
                };
            case "white-red":
                return function (x) {
                    x = 255 - x;
                    return "rgb(255," + x + "," + x + ")";
                };
            case "white-green":
                return function (x) {
                    x = 255 - x;
                    return "rgb(" + x + ",255," + x + ")";
                };
            case "white-blue":
            default:
                return function (x) {
                    x = 255 - x;
                    return "rgb(" + x + "," + x + ",255)";
                };
        }
    }, [options === null || options === void 0 ? void 0 : options.theme]);
    // util function
    var baseStyle = React.useMemo(function () {
        switch (options === null || options === void 0 ? void 0 : options.theme) {
            case "black-white":
                return function () { return 255; };
            case "white-black":
                return function () { return 255; };
            case "black-red":
                return function () { return 255; };
            case "black-green":
                return function () { return 255; };
            case "black-blue":
                return function () { return 255; };
            case "white-red":
                return function () { return 255; };
            case "white-green":
                return function () { return 255; };
            case "white-blue":
            default:
                return function () { return 255; };
        }
    }, [options === null || options === void 0 ? void 0 : options.theme]);
    // When new data arrive update charts
    React.useEffect(function () {
        var drawLine = function (data) {
            var canvas = lineCanvasRef.current;
            if (canvas === null)
                return false;
            var ctx = canvas.getContext("2d");
            if (ctx === null)
                return false;
            var dx = canvas.width / data.length;
            var dk = canvas.height / maxYScaleValue;
            var x = dx / 2;
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = fillStyle(baseStyle());
            ctx.lineWidth = 1;
            ctx.lineCap = "round";
            ctx.lineJoin = "round";
            ctx.beginPath();
            ctx.moveTo(x, (maxYScaleValue - data[0]) * dk);
            for (var _i = 0, _a = data.slice(1); _i < _a.length; _i++) {
                var value = _a[_i];
                x += dx;
                ctx.lineTo(x, (maxYScaleValue - value) * dk);
            }
            ctx.stroke();
            return true;
        };
        var drawHeatmap = function (data) {
            var canvas = heatmapCanvasRef.current;
            if (canvas === null)
                return false;
            var ctx = canvas.getContext("2d");
            if (ctx === null)
                return false;
            // dx can be floating point, then it glitches
            // https://stackoverflow.com/questions/58136632/fillrect-not-overlapping-exactly-when-float-numbers-are-used
            // https://html5rocks.com/en/tutorials/canvas/performance/#toc-avoid-float
            var dx = canvas.width / data.length;
            var dy = layout.heatmap.height / options.zAxis.displayBins;
            var x = 0;
            /**
             * The shift operation was carefully chosen to maximize performance.
             * It is implemented by drawImage - canvas is drawn onto itself with
             * an offset.
             * This effectively deletes anything that is shifted beyond canvas
             * in a single operation. Experimental evaluation revealed this
             * method to be much faster than using putImageData method.
             */
            ctx.drawImage(canvas, 0, dy);
            for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
                var value = data_1[_i];
                ctx.fillStyle = fillStyle(value / maxYScaleValue * baseStyle());
                ctx.fillRect(x, 0, dx, dy);
                x += dx;
            }
            return true;
        };
        if (data.y.length !== 0) {
            drawLine(data.y);
            drawHeatmap(data.y);
        }
        // Deliberatly missing dependencies: 'layout.heatmap.height', 'maxYScaleValue', and 'options.zAxis.displayBins'.
        // eslint-disable-next-line
    }, [data, fillStyle, baseStyle]);
    var yScale = React.useMemo(function () {
        var Xoffset = 5;
        var Yoffset = 16;
        var scaleStyle = {
            marginTop: layout.scale.marginTop,
            borderWidth: 1,
            borderStyle: "solid",
            borderColor: "black"
        };
        return (React.createElement("svg", { width: layout.width, height: layout.scale.height, overflow: "visible", style: scaleStyle },
            React.createElement("defs", null,
                React.createElement("linearGradient", { id: "linearGradient" },
                    React.createElement("stop", { offset: "0%", "stop-color": fillStyle(0) }),
                    React.createElement("stop", { offset: "100%", "stop-color": fillStyle(baseStyle()) }))),
            React.createElement("rect", { fill: "url('#linearGradient')", width: layout.width, height: layout.scale.height }),
            React.createElement("text", { x: Xoffset, y: layout.scale.height + Yoffset, fill: "black", stroke: "black", textAnchor: "start" }, minYScaleValue),
            React.createElement("text", { x: layout.width - Xoffset, y: layout.scale.height + Yoffset, fill: "black", stroke: "black", textAnchor: "end" }, maxYScaleValue)));
    }, [layout, fillStyle, baseStyle, minYScaleValue, maxYScaleValue]);
    return (React.createElement("div", { style: containerStyle },
        React.createElement("div", { style: lineContainerStyle },
            React.createElement(YAxis, __assign({}, options.yAxis, { width: layout.width, height: layout.line.height })),
            React.createElement("canvas", { id: "lineChart", ref: lineCanvasRef, width: layout.width, height: layout.line.height, style: __assign({}, canvasStyle) }),
            React.createElement(XAxis, __assign({}, options.xAxis, { width: layout.width, height: layout.line.height, x: data.x }))),
        React.createElement("div", { style: heatmapContainerStyle },
            React.createElement(ZAxis, __assign({}, options.zAxis, { z: data.z, width: layout.width, height: layout.heatmap.height })),
            React.createElement("canvas", { id: "heatmapChart", ref: heatmapCanvasRef, width: layout.width, height: layout.heatmap.height, style: __assign(__assign({}, canvasStyle), heatmapCanvasStyle) }, "Your browser does not support <canvas> tag element!"),
            React.createElement(XAxis, __assign({}, options.xAxis, { width: layout.width, height: layout.heatmap.height, x: data.x, displayGrid: false }))),
        React.createElement("div", { style: scaleContainerStyle }, yScale)));
};
var XAxis = React.memo(function (_a) {
    var width = _a.width, height = _a.height, values = _a.values, x = _a.x, _b = _a.displayAxis, displayAxis = _b === void 0 ? true : _b, _c = _a.displayGrid, displayGrid = _c === void 0 ? true : _c, _d = _a.color, color = _d === void 0 ? "black" : _d;
    if (!displayAxis && !displayGrid)
        return (React.createElement(React.Fragment, null));
    var strokeWidth = 0.25;
    var t = 5; // tick size
    var dx = width / x.length;
    var pos = [];
    x.forEach(function (v, i) {
        if (values.includes(v)) {
            pos.push(i * dx + dx / 2);
        }
    });
    var gridLines = [];
    var axisLabels = [];
    var axisLines = [];
    pos.forEach(function (v, i) {
        if (displayGrid) {
            gridLines.push(React.createElement("path", { key: v, d: "M " + v + "," + 0 + " L " + v + "," + -height }));
        }
        if (displayAxis) {
            axisLabels.push(React.createElement("text", { key: v, x: v, y: t + 15, textAnchor: "middle" }, values[i].toString()));
            axisLines.push(React.createElement("path", { key: v, d: "M " + v + ",0 L " + v + "," + t }));
        }
    });
    return (React.createElement("svg", { id: "xAxis", width: width, height: 10, style: { position: "absolute", left: 0, top: height }, overflow: "visible" },
        React.createElement("g", { fill: color, stroke: color, strokeWidth: strokeWidth }, gridLines),
        React.createElement("g", { fill: color, stroke: color, strokeWidth: 4 * strokeWidth }, axisLines),
        React.createElement("g", { fill: color, stroke: color }, axisLabels)));
});
var YAxis = React.memo(function (_a) {
    var width = _a.width, height = _a.height, values = _a.values, _b = _a.displayAxis, displayAxis = _b === void 0 ? true : _b, _c = _a.displayGrid, displayGrid = _c === void 0 ? true : _c, _d = _a.color, color = _d === void 0 ? "black" : _d;
    if (!displayAxis && !displayGrid)
        return (React.createElement(React.Fragment, null));
    var strokeWidth = 0.25;
    var w = 30; // svg width
    var t = 5; // tick width
    var m = values[values.length - 1];
    var pos = values.map(function (v) {
        return Math.floor(height - v * height / m);
    });
    // create paths and texts
    var gridLines = [];
    var axisLines = [];
    var axisLabels = [];
    pos.forEach(function (v, i) {
        if (displayGrid) {
            gridLines.push(React.createElement("path", { key: v, d: "M " + w + "," + v + " L " + (width + w) + "," + v }));
        }
        if (displayAxis) {
            axisLabels.push(React.createElement("text", { key: v, "text-anchor": "end", x: w - 2 * t, y: v + 5 }, values[i]));
            axisLines.push(React.createElement("path", { key: v, d: "M " + (w - t) + "," + v + " L " + w + "," + v }));
        }
    });
    // width and height of yAxis is irrelevant because it is positioned abolutely
    return (React.createElement("svg", { id: "yAxis", overflow: "visible", style: { position: "absolute", left: -w } },
        React.createElement("g", { fill: color, stroke: color, strokeWidth: strokeWidth }, gridLines),
        React.createElement("g", { fill: color, stroke: color, strokeWidth: 4 * strokeWidth }, axisLines),
        React.createElement("g", { fill: color, stroke: color }, axisLabels)));
});
var ZAxis = function (_a) {
    var width = _a.width, height = _a.height, z = _a.z, displayBins = _a.displayBins, _b = _a.displayAxis, displayAxis = _b === void 0 ? true : _b, _c = _a.color, color = _c === void 0 ? "black" : _c;
    var axisLabelsRef = React.useRef([]);
    var _d = React.useState([]), axisLabels = _d[0], setAxisLabels = _d[1];
    var strokeWidth = 0.25;
    var w = 30; // svg width
    var t = 5; // tick width
    var pos = React.useMemo(function () {
        var dz = height / displayBins;
        return Array.from(Array(displayBins), function (v, i) {
            return i * dz + dz / 2;
        });
    }, [height, displayBins]);
    var axisLines = React.useMemo(function () {
        var axisLines = [];
        pos.forEach(function (v, i) {
            axisLines.push(React.createElement("path", { key: v, d: "M " + (w - t) + "," + v + " L " + w + "," + v }));
        });
        return axisLines;
    }, [pos, w, t]);
    // on new z value recreate all <text> labels
    React.useEffect(function () {
        if (axisLabelsRef.current.length < displayBins) {
            axisLabelsRef.current.unshift(z);
        }
        else {
            axisLabelsRef.current.pop();
            axisLabelsRef.current.unshift(z);
        }
        var labels = [];
        axisLabelsRef.current.forEach(function (l, i) {
            switch (typeof l) {
                case "object":
                    labels.push(React.createElement("text", { key: i + "-" + l.toLocaleTimeString(), "text-anchor": "end", x: w - 2 * t, y: pos[i] + 5 }, l.toLocaleTimeString()));
                    break;
                case "string":
                    labels.push(React.createElement("text", { key: i + "-" + l, "text-anchor": "end", x: w - 2 * t, y: pos[i] + 5 }, l));
                    break;
                case "number":
                    labels.push(React.createElement("text", { key: i + "-" + l.toLocaleString(), "text-anchor": "end", x: w - 2 * t, y: pos[i] + 5 }, l.toLocaleString()));
                    break;
                default:
                    break;
            }
        });
        setAxisLabels(labels);
        // Deliberatly missing dependencies: 'displayBins' and 'pos'.
        // eslint-disable-next-line
    }, [z]);
    if (!displayAxis)
        return (React.createElement(React.Fragment, null));
    // width and height of zAxis is irrelevant because it is positioned abolutely
    return (React.createElement("svg", { id: "zAxis", overflow: "visible", style: { position: "absolute", left: -w } },
        React.createElement("g", { fill: color, stroke: color, "stroke-width": 4 * strokeWidth }, axisLines),
        React.createElement("g", { fill: color, stroke: color }, axisLabels)));
};
export default Spectrogram;
